<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon CONNECT | Model Visualizer</title>
    <link rel="icon" type="image/png" href="{{ url_for('static', filename='logo.png') }}">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true, theme: 'dark' });
    </script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Space+Grotesk:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                        display: ['Space Grotesk', 'sans-serif'],
                        mono: ['JetBrains Mono', 'monospace'],
                    },
                    colors: {
                        background: '#0a0a0b',
                        surface: '#1a1a1d',
                        surface2: '#252529',
                        primary: '#6366f1',
                        border: '#2a2a2f',
                        thought: '#FF00FF',
                        search: '#00FFFF',
                        code: '#FF0000'
                    }
                }
            }
        }
    </script>
    <style>
        body { background-color: #0a0a0b; color: #fafafa; }
        .custom-scrollbar::-webkit-scrollbar { width: 6px; height: 6px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: transparent; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: rgba(255, 255, 255, 0.1); border-radius: 4px; }
        .tab-btn.active { border-bottom: 2px solid #6366f1; color: #6366f1; }
        .plot-container { min-height: 400px; width: 100%; }
        .mermaid { background: transparent; }
    </style>
</head>
<body class="h-screen flex flex-col overflow-hidden font-sans">
    <!-- Header -->
    <header class="h-16 border-b border-border flex items-center justify-between px-6 bg-surface/50 backdrop-blur-md z-20">
        <div class="flex items-center gap-3">
            <img src="{{ url_for('static', filename='logo.png') }}" class="w-8 h-8 rounded-lg">
            <h1 class="text-xl font-bold font-display tracking-tight">
                <span class="text-code">N</span><span class="text-thought">e</span><span class="text-primary">o</span><span class="text-search">n</span> <span class="text-gray-400">CONNECT</span>
            </h1>
        </div>
        <div class="flex items-center gap-4">
            <a href="/neoncore" class="text-sm text-gray-400 hover:text-white transition-colors">NeonCore Chat</a>
            <div class="h-4 w-[1px] bg-border"></div>
            <span class="text-sm font-mono text-muted">{{ username }}</span>
            <a href="/logout" class="text-sm text-red-400 hover:text-red-300">Logout</a>
        </div>
    </header>

    <main class="flex-1 flex overflow-hidden">
        <!-- Sidebar: Model Selection & Info -->
        <aside class="w-80 border-r border-border flex flex-col bg-surface/30">
            <div class="p-4 border-b border-border">
                <label class="block text-xs font-mono uppercase text-gray-500 mb-2">Selected Model</label>
                <select id="model-select" class="w-full bg-surface border border-border rounded-lg px-3 py-2 text-sm focus:outline-none focus:ring-1 focus:ring-primary">
                    <option value="">Loading models...</option>
                </select>
            </div>
            <div id="model-info" class="p-4 flex-1 overflow-y-auto custom-scrollbar space-y-4">
                <div class="animate-pulse space-y-3">
                    <div class="h-4 bg-surface2 rounded w-3/4"></div>
                    <div class="h-4 bg-surface2 rounded w-1/2"></div>
                    <div class="h-20 bg-surface2 rounded"></div>
                </div>
            </div>
        </aside>

        <!-- Main Content: Controls & Tabs -->
        <div class="flex-1 flex flex-col overflow-hidden">
            <!-- Top Bar: Prompt Input -->
            <div class="p-4 border-b border-border bg-surface/10">
                <div class="max-w-4xl mx-auto flex gap-3">
                    <textarea id="prompt-input" rows="2" placeholder="Enter prompt to visualize..." 
                        class="flex-1 bg-surface border border-border rounded-xl px-4 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-primary/50 transition-all resize-none font-light">Harry looked at the mirror and saw</textarea>
                    <button id="visualize-btn" class="px-6 py-2 bg-primary hover:bg-primary/80 text-white rounded-xl font-medium transition-all shadow-lg shadow-primary/20 disabled:opacity-50">
                        Visualize
                    </button>
                </div>
            </div>

            <!-- Tabs Navigation -->
            <div class="flex border-b border-border bg-surface/5 px-4 overflow-x-auto">
                <button class="tab-btn px-4 py-3 text-sm font-medium text-gray-400 hover:text-white transition-colors active" data-tab="architecture">Architecture</button>
                <button class="tab-btn px-4 py-3 text-sm font-medium text-gray-400 hover:text-white transition-colors" data-tab="single-head">Single Head Detail</button>
                <button class="tab-btn px-4 py-3 text-sm font-medium text-gray-400 hover:text-white transition-colors" data-tab="all-heads">All Heads Grid</button>
                <button class="tab-btn px-4 py-3 text-sm font-medium text-gray-400 hover:text-white transition-colors" data-tab="mlp-acts">MLP & Gate</button>
                <button class="tab-btn px-4 py-3 text-sm font-medium text-gray-400 hover:text-white transition-colors" data-tab="next-token">Next Token</button>
                <button class="tab-btn px-4 py-3 text-sm font-medium text-gray-400 hover:text-white transition-colors" data-tab="inference">Live Chat</button>
            </div>

            <!-- Tab Content -->
            <div id="tab-content" class="flex-1 overflow-y-auto p-6 custom-scrollbar">
                <!-- Placeholder for dynamic content -->
                <div id="viz-container" class="max-w-6xl mx-auto">
                    <div class="text-center py-20 text-gray-500">
                        <svg class="w-16 h-16 mx-auto mb-4 opacity-20" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="1" d="M9.75 17L9 21h6l-.75-4M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"></path></svg>
                        <p>Select a model and enter a prompt to begin architectural visualization.</p>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <script>
        // JS state
        let currentModel = null;
        let lastVisData = null;
        let models = [];

        // Elements
        const modelSelect = document.getElementById('model-select');
        const modelInfo = document.getElementById('model-info');
        const promptInput = document.getElementById('prompt-input');
        const visualizeBtn = document.getElementById('visualize-btn');
        const tabBtns = document.querySelectorAll('.tab-btn');
        const vizContainer = document.getElementById('viz-container');

        // Initialize
        async function init() {
            try {
                const res = await fetch('/api/neonconnect/models');
                models = await res.json();
                modelSelect.innerHTML = models.map(m => `<option value="${m.id}">${m.label}</option>`).join('');
                if (models.length > 0) {
                    selectModel(models[0].id);
                }
            } catch (e) {
                console.error("Failed to load models:", e);
            }
        }

        function selectModel(id) {
            currentModel = models.find(m => m.id === id);
            modelInfo.innerHTML = `
                <div class="space-y-4">
                    <div>
                        <h3 class="text-lg font-bold text-white">${currentModel.model_name}</h3>
                        <p class="text-xs text-gray-500 font-mono">ID: ${currentModel.id}</p>
                    </div>
                    <div class="bg-surface p-3 rounded-lg border border-border">
                        <div class="grid grid-cols-2 gap-2 text-xs">
                            <span class="text-gray-500">Architecture</span>
                            <span class="text-right text-gray-300">${currentModel.model_name}</span>
                            <span class="text-gray-500">Tokenizer</span>
                            <span class="text-right text-gray-300">${currentModel.tok_name}</span>
                            <span class="text-gray-500">Dataset</span>
                            <span class="text-right text-gray-300">${currentModel.data_name}</span>
                        </div>
                    </div>
                    <div class="text-xs text-gray-400 leading-relaxed">
                        Architecture details for ${currentModel.model_name} are optimized for CPU-based inference on PythonAnywhere.
                    </div>
                </div>
            `;
            // If architecture tab is active, reload it to maybe change diagram
            if (document.querySelector('.tab-btn.active').dataset.tab === 'architecture') {
                renderArchitecture();
            }
        }

        modelSelect.addEventListener('change', (e) => selectModel(e.target.value));

        // Tab Switching
        tabBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                tabBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                renderTab(btn.dataset.tab);
            });
        });

        async function visualize() {
            if (!currentModel) return;
            visualizeBtn.disabled = true;
            visualizeBtn.textContent = "Thinking...";
            vizContainer.innerHTML = `<div class="flex items-center justify-center py-20"><div class="w-8 h-8 border-4 border-primary border-t-transparent rounded-full animate-spin"></div></div>`;

            try {
                const res = await fetch('/api/neonconnect/visualize', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        model_id: currentModel.id,
                        prompt: promptInput.value
                    })
                });
                lastVisData = await res.json();
                renderTab(document.querySelector('.tab-btn.active').dataset.tab);
            } catch (e) {
                vizContainer.innerHTML = `<div class="p-4 bg-red-500/10 border border-red-500/20 text-red-400 rounded-lg">Error: ${e.message}</div>`;
            } finally {
                visualizeBtn.disabled = false;
                visualizeBtn.textContent = "Visualize";
            }
        }

        visualizeBtn.addEventListener('click', visualize);

        function renderTab(tabId) {
            vizContainer.innerHTML = '';
            
            if (tabId === 'architecture') {
                renderArchitecture();
                return;
            }

            if (!lastVisData) {
                vizContainer.innerHTML = `
                    <div class="text-center py-20 text-gray-500">
                        <p>Please click "Visualize" to analyze the model response first.</p>
                    </div>`;
                return;
            }

            if (tabId === 'single-head') {
                renderSingleHead();
            } else if (tabId === 'all-heads') {
                renderAllHeads();
            } else if (tabId === 'mlp-acts') {
                renderMLP();
            } else if (tabId === 'next-token') {
                renderNextToken();
            } else if (tabId === 'inference') {
                renderInference();
            }
        }

        function cleanToken(t) {
            return t.replace('Ġ', '·').replace('Ċ', '↵').replace('▁', '·');
        }

        function getTokenLabels(tokens) {
            return tokens.map((t, i) => `${i}:${cleanToken(t)}`);
        }

        function renderArchitecture() {
            // Neon167 Diagram
            const mermaidCode = `
graph TD
    A["Input Tokens [B, 256]"] --> B["Embedding Matrix [1024, 272]"]
    B --> C["Residual Stream [B, 256, 272]"]
    
    subgraph "Block (x4)"
    C --> D["RMSNorm"]
    D --> E["C_Attn Linear [272, 1088]"]
    E --> F["QKVI Split [4x 272]"]
    F --> G["K3 DepthConv [272, 1, 3]"]
    G --> H["4-Head Split [68-dim]"]
    H --> I["SDPA + Intent Gate"]
    I --> J["C_Proj Linear [272, 272]"]
    J --> K["( + ) Residual Connection"]
    
    K --> L["RMSNorm"]
    L --> M["K9 DepthConv [272, 1, 9]"]
    M --> N["Hydra Gate [272, 1072]"]
    L --> O["Content W1 [272, 1072]"]
    O --> P["Hadamard Product (*)"]
    N --> P
    P --> Q["W2 Linear [1072, 272]"]
    Q --> R["( + ) Residual Connection"]
    end
    
    R --> S["Final RMSNorm"]
    S --> T["LM Head Linear [272, 1024]"]
    T --> U["Next Token Probabilities"]
            `;
            
            vizContainer.innerHTML = `
                <div class="flex justify-center p-4">
                    <div class="mermaid text-center bg-surface p-4 rounded-xl border border-border">
                        ${mermaidCode}
                    </div>
                </div>
            `;
            // Trigger mermaid render
            import('https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs').then(m => {
                m.default.contentLoaded(); 
            });
        }

        function renderSingleHead() {
            const config = lastVisData.config;
            const n_layers = config.n_layers;
            const n_heads = config.n_head;

            vizContainer.innerHTML = `
                <div class="space-y-6">
                    <div class="flex gap-4 items-end">
                        <div class="flex-1">
                            <label class="block text-xs font-mono text-gray-500 mb-1">Layer</label>
                            <select id="layer-sel" class="w-full bg-surface border border-border rounded-lg px-3 py-2 text-sm">
                                ${Array.from({length: n_layers}, (_, i) => `<option value="${i}">Layer ${i}</option>`).join('')}
                            </select>
                        </div>
                        <div class="flex-1">
                            <label class="block text-xs font-mono text-gray-500 mb-1">Head</label>
                            <select id="head-sel" class="w-full bg-surface border border-border rounded-lg px-3 py-2 text-sm">
                                ${Array.from({length: n_heads}, (_, i) => `<option value="${i}">Head ${i}</option>`).join('')}
                            </select>
                        </div>
                    </div>
                    
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-4">
                        <div class="space-y-2">
                            <h4 class="text-xs font-mono text-gray-400">Attention Matrix</h4>
                            <div id="attn-plot" class="plot-container bg-surface/20 rounded-xl overflow-hidden border border-border"></div>
                        </div>
                        <div class="space-y-2">
                            <h4 class="text-xs font-mono text-gray-400">Intent Vector (I)</h4>
                            <div id="intent-plot" class="plot-container bg-surface/20 rounded-xl overflow-hidden border border-border"></div>
                        </div>
                        <div class="space-y-2">
                            <h4 class="text-xs font-mono text-gray-400">Query Vector (Q)</h4>
                            <div id="q-plot" class="plot-container bg-surface/20 rounded-xl overflow-hidden border border-border"></div>
                        </div>
                        <div class="space-y-2">
                            <h4 class="text-xs font-mono text-gray-400">Key Vector (K)</h4>
                            <div id="k-plot" class="plot-container bg-surface/20 rounded-xl overflow-hidden border border-border"></div>
                        </div>
                    </div>
                </div>
            `;

            const update = () => {
                const l = parseInt(document.getElementById('layer-sel').value);
                const h = parseInt(document.getElementById('head-sel').value);
                plotSingleHeadDetailed(l, h);
            };

            document.getElementById('layer-sel').addEventListener('change', update);
            document.getElementById('head-sel').addEventListener('change', update);
            update();
        }

        function plotSingleHeadDetailed(layer, head) {
            const tokens = getTokenLabels(lastVisData.tokens);
            // Attn: [layer][batch][head][q][k]
            const zAttn = lastVisData.attn[layer][0][head];
            
            // Q, K, V, I: [layer][batch][n_head][T][head_dim] -> we need [T][head_dim] for specific head
            // Wait, my model_engine structure for Q/K/V/I might be [layer][batch][T][n_head][head_dim] or flattened?
            // Neon167.py: q = q.view(B, T, self.n_head, self.head_dim)
            // Hook captures tensor.
            // Let's assume structure is [batch, T, n_head, head_dim] based on code order.
            
            // But wait, the hook in model_engine.py:
            // logits = q @ k.transpose(-2, -1) * s
            // q input to SDPA is usually [B, n_head, T, head_dim].
            // Neon167.py: q, k, v = q.transpose(1, 2), ... -> [B, n_head, T, head_dim]
            // So lastVisData.q[layer][0] is [n_head, T, head_dim].
            
            const head_dim = lastVisData.q[layer][0][0][0].length; // Check dims
            
            const getVectorData = (source, l, h) => {
                // source[l][0] is [n_head, T, head_dim]
                const headData = source[l][0][h]; // [T, head_dim]
                // Transpose for heatmap (Dimensions on X, Tokens on Y)
                // return headData; 
                // Actually Plotly heatmap: z is array of arrays.
                // We want Tokens on Y axis? Or X?
                // Let's put Tokens on Y, Dims on X.
                return headData;
            };

            const plotHeatmap = (divId, zData, title, colorscale='RdBu') => {
                Plotly.newPlot(divId, [{
                    z: zData,
                    x: Array.from({length: zData[0].length}, (_, i) => `d${i}`),
                    y: tokens,
                    type: 'heatmap', colorscale: colorscale, zmid: 0
                }], {
                    title: title,
                    paper_bgcolor: 'rgba(0,0,0,0)',
                    plot_bgcolor: 'rgba(0,0,0,0)',
                    font: { color: '#a1a1aa', size: 9 },
                    xaxis: { title: 'Dimension', showticklabels: false },
                    yaxis: { autorange: 'reversed', showticklabels: false },
                    margin: { l: 40, r: 20, b: 30, t: 30 }
                }, {displayModeBar: false});
            };

            // Plot Attn Matrix
            Plotly.newPlot('attn-plot', [{
                z: zAttn, x: tokens, y: tokens, type: 'heatmap', colorscale: 'Blues'
            }], {
                title: 'Attention Matrix',
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)',
                font: { color: '#a1a1aa', size: 9 },
                xaxis: { showticklabels: false },
                yaxis: { autorange: 'reversed', showticklabels: false },
                margin: { l: 40, r: 20, b: 30, t: 30 }
            }, {displayModeBar: false});

            // Plot Vectors
            plotHeatmap('q-plot', getVectorData(lastVisData.q, layer, head), 'Query (Q)');
            plotHeatmap('k-plot', getVectorData(lastVisData.k, layer, head), 'Key (K)');
            // Intent is stored in lastVisData.intent
            plotHeatmap('intent-plot', getVectorData(lastVisData.intent, layer, head), 'Intent (I)', 'Viridis');
        }

        function renderAllHeads() {
            const n_layers = lastVisData.config.n_layers;
            const n_heads = lastVisData.config.n_head;
            const tokens = getTokenLabels(lastVisData.tokens);
            
            // Grid CSS
            const gridStyle = `grid-template-columns: repeat(${n_heads}, minmax(0, 1fr));`;
            
            let html = `<div class="grid gap-2" style="${gridStyle}">`;
            
            // Headers
            for(let h=0; h<n_heads; h++) {
                html += `<div class="text-center text-xs font-mono text-gray-500">Head ${h}</div>`;
            }
            
            for(let l=0; l<n_layers; l++) {
                for(let h=0; h<n_heads; h++) {
                    const id = `grid-l${l}-h${h}`;
                    html += `<div id="${id}" class="aspect-square bg-surface/20 border border-border rounded"></div>`;
                }
            }
            html += `</div>`;
            
            // Row Labels (tricky with grid, maybe just use tooltips or overlay)
            // Let's wrap rows? No, CSS grid is easier.
            // Just add a side column? 
            // Let's stick to simple grid first.
            
            vizContainer.innerHTML = `
                <div class="flex">
                    <div class="flex flex-col justify-around mr-2 pt-6 pb-2">
                        ${Array.from({length: n_layers}, (_, i) => `<div class="text-xs font-mono text-gray-500 rotate-180" style="writing-mode: vertical-rl">Layer ${i}</div>`).join('')}
                    </div>
                    <div class="flex-1 space-y-4">
                        <div class="flex justify-between px-2">
                            ${Array.from({length: n_heads}, (_, i) => `<div class="text-xs font-mono text-gray-500">Head ${i}</div>`).join('')}
                        </div>
                        <div class="grid gap-2" style="grid-template-columns: repeat(${n_heads}, 1fr);">
                            ${Array.from({length: n_layers * n_heads}, (_, i) => {
                                const l = Math.floor(i / n_heads);
                                const h = i % n_heads;
                                return `<div id="grid-l${l}-h${h}" class="aspect-square bg-surface/20 border border-border rounded relative group">
                                    <div class="absolute inset-0 bg-black/50 opacity-0 group-hover:opacity-100 flex items-center justify-center text-xs pointer-events-none transition-opacity">L${l}H${h}</div>
                                </div>`;
                            }).join('')}
                        </div>
                    </div>
                </div>
            `;

            // Plot
            for(let l=0; l<n_layers; l++) {
                for(let h=0; h<n_heads; h++) {
                    const z = lastVisData.attn[l][0][h];
                    Plotly.newPlot(`grid-l${l}-h${h}`, [{
                        z: z, type: 'heatmap', colorscale: 'Blues', showscale: false
                    }], {
                        margin: { l: 0, r: 0, b: 0, t: 0 },
                        xaxis: { showticklabels: false, showgrid: false, zeroline: false },
                        yaxis: { autorange: 'reversed', showticklabels: false, showgrid: false, zeroline: false },
                        paper_bgcolor: 'rgba(0,0,0,0)',
                        plot_bgcolor: 'rgba(0,0,0,0)'
                    }, {staticPlot: true}); // Static for speed
                }
            }
        }

        function renderMLP() {
            const n_layers = lastVisData.config.n_layers;
            vizContainer.innerHTML = `
                <div class="space-y-6">
                    <div>
                        <label class="block text-xs font-mono text-gray-500 mb-1">Layer Details</label>
                        <select id="mlp-layer-sel" class="w-full bg-surface border border-border rounded-lg px-3 py-2 text-sm max-w-xs">
                            ${Array.from({length: n_layers}, (_, i) => `<option value="${i}">Layer ${i}</option>`).join('')}
                        </select>
                    </div>
                    
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-4">
                        <div class="space-y-2">
                            <h4 class="text-xs font-mono text-gray-400">MLP Hidden State (Content)</h4>
                            <div id="mlp-act-plot" class="plot-container bg-surface/20 rounded-xl border border-border" style="height: 500px;"></div>
                        </div>
                        <div class="space-y-2">
                            <h4 class="text-xs font-mono text-gray-400">MLP Conv Gate (Filter)</h4>
                            <div id="mlp-gate-plot" class="plot-container bg-surface/20 rounded-xl border border-border" style="height: 500px;"></div>
                        </div>
                    </div>
                </div>
            `;

            const update = () => plotMLPAct(parseInt(document.getElementById('mlp-layer-sel').value));
            document.getElementById('mlp-layer-sel').addEventListener('change', update);
            update();
        }

        function plotMLPAct(layer) {
            const tokens = getTokenLabels(lastVisData.tokens);
            // MLP input: [batch, T, d_ff]
            const data = lastVisData.mlp[layer].input[0]; 
            const z = data[0].map((_, colIndex) => data.map(row => row[colIndex]));

            Plotly.newPlot('mlp-act-plot', [{
                z: z, x: tokens, y: Array.from({length: z.length}, (_, i) => `d${i}`),
                type: 'heatmap', colorscale: 'RdBu', zmid: 0
            }], {
                title: `Content`,
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)',
                font: { color: '#a1a1aa', size: 10 },
                xaxis: { tickangle: 45, automargin: true },
                yaxis: { automargin: true, showticklabels: false },
                margin: { l: 50, r: 20, b: 50, t: 30 }
            });

            // Gate (Conv9)
            // conv list is flat. Per layer we have [Q, K, V, I, MLP].
            // So MLP index = layer * 5 + 4
            const convIndex = layer * 5 + 4;
            if (lastVisData.conv && lastVisData.conv[convIndex]) {
                const gateData = lastVisData.conv[convIndex].data[0]; // [C, T] or [d_model, T]
                // Transpose? No, usually visualizer.py showed it as [Dims, T]
                // Let's check format. Engine: out.detach().cpu().
                // Conv1d output is [Batch, Channel, Length].
                // So gateData is [Channel, Length].
                // We want Length on Y axis for consistency?
                // Visualizer usually does Length on X?
                // My other plots have Tokens on Y? No, `x: tokens, y: tokens` for attn.
                // Single Head vectors: x: dims, y: tokens.
                // So let's align: x: dims, y: tokens.
                // gateData is [D, T]. We need [T, D] for x=D, y=T.
                
                // Transpose gateData
                const T = gateData[0].length;
                const D = gateData.length;
                const zGate = [];
                for(let t=0; t<T; t++) {
                    const row = [];
                    for(let d=0; d<D; d++) row.push(gateData[d][t]);
                    zGate.push(row);
                }
                
                // Now zGate is [T][D]. 
                // But wait, my plotHeatmap helper takes zData where rows are Y.
                // So if Y is Tokens, then zData should be [T][D].
                // But my single head vectors helper above passed [T][D] but mapped Y to Tokens.
                // Wait, single head vectors: `source[l][0][h]` is [T, head_dim].
                // The Plotly heatmap `z` expects array of arrays (rows).
                // `y: tokens` (length T).
                // So `z` must have T rows. Correct.
                
                // So for gate, we also want T rows.
                // zGate is [T][D].
                // But we want Dims on X.
                // So z: zGate (T rows, D cols)
                // y: tokens (T)
                // x: dims (D)
                
                // Wait, heatmap `z` is usually [y][x].
                // If y=Tokens, then z[0] corresponds to Token 0.
                // z[0] is an array of values for X (Dims).
                // So z must be [T][D].
                
                // My conv data `gateData` is [D][T].
                // So `gateData[d][t]`
                // I need `z[t][d]`.
                
                // Let's transpose:
                const zFinal = [];
                for(let t=0; t<T; t++) {
                    const row = [];
                    for(let d=0; d<D; d++) {
                        row.push(gateData[d][t]);
                    }
                    zFinal.push(row);
                }

                Plotly.newPlot('mlp-gate-plot', [{
                    z: zFinal, // [T][D] - actually, wait.
                    // If Z is [Rows][Cols].
                    // Rows match Y. Cols match X.
                    // Y is Tokens (T). X is Dims (D).
                    // So Z should be [T][D].
                    // Correct.
                    
                    x: Array.from({length: D}, (_, i) => `d${i}`),
                    y: tokens,
                    type: 'heatmap', colorscale: 'Viridis'
                }], {
                    title: `Gate Pattern (Conv k=9)`,
                    paper_bgcolor: 'rgba(0,0,0,0)',
                    plot_bgcolor: 'rgba(0,0,0,0)',
                    font: { color: '#a1a1aa', size: 10 },
                    xaxis: { tickangle: 45, automargin: true },
                    yaxis: { automargin: true, showticklabels: false },
                    margin: { l: 50, r: 20, b: 50, t: 30 }
                });
            } else {
                document.getElementById('mlp-gate-plot').innerHTML = '<div class="flex items-center justify-center h-full text-gray-500">No Conv Data</div>';
            }
        }

        function renderNextToken() {
            vizContainer.innerHTML = `<div id="probs-plot" class="plot-container bg-surface/20 rounded-xl border border-border" style="height: 600px;"></div>`;
            
            const logits = lastVisData.logits;
            const maxLogit = Math.max(...logits);
            const exps = logits.map(l => Math.exp(l - maxLogit));
            const sumExps = exps.reduce((a, b) => a + b, 0);
            const probs = exps.map(e => e / sumExps);

            const indexed = probs.map((p, i) => ({p, i}));
            indexed.sort((a, b) => b.p - a.p);
            const top20 = indexed.slice(0, 20);

            Plotly.newPlot('probs-plot', [{
                x: top20.map(x => x.p),
                y: top20.map(x => `ID:${x.i}`),
                type: 'bar', orientation: 'h', marker: {color: '#6366f1'}
            }], {
                title: 'Next Token Probabilities (Top 20)',
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)',
                font: { color: '#a1a1aa', size: 10 },
                xaxis: { gridcolor: '#2a2a2f' },
                yaxis: { autorange: 'reversed' },
                margin: { l: 100, r: 50, b: 50, t: 50 }
            });
        }

        function renderInference() {
            vizContainer.innerHTML = `
                <div class="max-w-2xl mx-auto space-y-6">
                    <div class="bg-surface p-6 rounded-2xl border border-border shadow-xl">
                        <h3 class="text-lg font-bold mb-4">Chat with ${currentModel.model_name}</h3>
                        <div id="chat-output" class="min-h-[200px] bg-background/50 rounded-xl p-4 mb-4 font-light leading-relaxed whitespace-pre-wrap text-gray-300 border border-border/50"></div>
                        <div class="flex gap-2">
                            <input id="chat-input" type="text" class="flex-1 bg-background border border-border rounded-lg px-4 py-2 text-sm focus:outline-none focus:ring-1 focus:ring-primary" placeholder="Ask something...">
                            <button id="chat-send" class="px-4 py-2 bg-primary rounded-lg text-sm font-medium">Send</button>
                        </div>
                    </div>
                </div>
            `;

            const out = document.getElementById('chat-output');
            const inp = document.getElementById('chat-input');
            const send = document.getElementById('chat-send');

            send.addEventListener('click', async () => {
                const p = inp.value;
                if (!p) return;
                send.disabled = true;
                out.textContent = "Generating...";
                
                try {
                    const res = await fetch('/api/neonconnect/generate', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            model_id: currentModel.id,
                            prompt: p,
                            max_tokens: 150
                        })
                    });
                    const data = await res.json();
                    out.textContent = data.result;
                } catch (e) {
                    out.textContent = "Error: " + e.message;
                } finally {
                    send.disabled = false;
                }
            });
        }

        init();
    </script>
</body>
</html>
